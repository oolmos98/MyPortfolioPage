"use strict";(self.webpackChunkmyportfolio=self.webpackChunkmyportfolio||[]).push([[1769],{1769:(t,i,e)=>{e.d(i,{Particle:()=>f});var s=e(8025),o=e(9135),a=e(8164),n=e(2496),r=e(753),h=e(1189),c=e(6480),l=e(8802);const p=.5;function d(t){if(!(0,a.hn)(t.outMode,t.checkModes))return;const i=2*t.radius;t.coord>t.maxCoord-i?t.setCb(-t.radius):t.coord<i&&t.setCb(t.radius)}class f{constructor(t,i){var e=this;this.container=i,this._calcPosition=function(t,i,a){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;for(const[,o]of t.plugins){const t=void 0!==o.particlePosition?o.particlePosition(i,e):void 0;if(t)return s.p.create(t.x,t.y,a)}const r=t.canvas.size,h=(0,o.Nx)({size:r,position:i}),c=s.p.create(h.x,h.y,a),l=e.getRadius(),p=e.options.move.outModes,f=i=>{d({outMode:i,checkModes:["bounce"],coord:c.x,maxCoord:t.canvas.size.width,setCb:t=>c.x+=t,radius:l})},u=i=>{d({outMode:i,checkModes:["bounce"],coord:c.y,maxCoord:t.canvas.size.height,setCb:t=>c.y+=t,radius:l})};if(f(p.left??p.default),f(p.right??p.default),u(p.top??p.default),u(p.bottom??p.default),e._checkOverlap(c,n)){const i=1;return e._calcPosition(t,void 0,a,n+i)}return c},this._calculateVelocity=()=>{const t=(0,o.$m)(this.direction).copy(),i=this.options.move;if("inside"===i.direction||"outside"===i.direction)return t;const e=(0,o.pu)((0,o.VG)(i.angle.value)),s=(0,o.pu)((0,o.VG)(i.angle.offset)),a={left:s-e*p,right:s+e*p};return i.straight||(t.angle+=(0,o.U4)((0,o.DT)(a.left,a.right))),i.random&&"number"===typeof i.speed&&(t.length*=(0,o.G0)()),t},this._checkOverlap=function(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const s=e.options.collisions,a=e.getRadius();if(!s.enable)return!1;const r=s.overlap;if(r.enable)return!1;const h=r.retries;if(h>=0&&i>h)throw new Error(`${n.dI} particle is overlapping and can't be placed`);return!!e.container.particles.find((i=>(0,o.Yf)(t,i.position)<a+i.getRadius()))},this._getRollColor=t=>{if(!t||!this.roll||!this.backColor&&!this.roll.alter)return t;const i=this.roll.horizontal&&this.roll.vertical?2:1,e=this.roll.horizontal?Math.PI*p:0;return Math.floor(((this.roll.angle??0)+e)/(Math.PI/i))%2?this.backColor?this.backColor:this.roll.alter?(0,c.yx)(t,this.roll.alter.type,this.roll.alter.value):t:t},this._initPosition=t=>{const i=this.container,e=(0,o.VG)(this.options.zIndex.value);this.position=this._calcPosition(i,t,(0,o.qE)(e,0,i.zLayers)),this.initialPosition=this.position.copy();const n=i.canvas.size;switch(this.moveCenter={...(0,a.E9)(this.options.move.center,n),radius:this.options.move.center.radius??0,mode:this.options.move.center.mode??"percent"},this.direction=(0,o.JY)(this.options.move.direction,this.position,this.moveCenter),this.options.move.direction){case"inside":this.outType="inside";break;case"outside":this.outType="outside"}this.offset=s.M.origin},this._engine=t}destroy(t){if(this.unbreakable||this.destroyed)return;this.destroyed=!0,this.bubble.inRange=!1,this.slow.inRange=!1;const i=this.container,e=this.pathGenerator,s=i.shapeDrawers.get(this.shape);s?.particleDestroy?.(this);for(const[,o]of i.plugins)o.particleDestroyed?.(this,t);for(const o of i.particles.updaters)o.particleDestroyed?.(this,t);e?.reset(this),this._engine.dispatchEvent("particleDestroyed",{container:this.container,data:{particle:this}})}async draw(t){const i=this.container,e=i.canvas;for(const[,s]of i.plugins)await e.drawParticlePlugin(s,this,t);await e.drawParticle(this,t)}getFillColor(){return this._getRollColor(this.bubble.color??(0,r.O_)(this.color))}getMass(){return this.getRadius()**2*Math.PI*p}getPosition(){return{x:this.position.x+this.offset.x,y:this.position.y+this.offset.y,z:this.position.z}}getRadius(){return this.bubble.radius??this.size.value}getStrokeColor(){return this._getRollColor(this.bubble.color??(0,r.O_)(this.strokeColor))}async init(t,i,e,s){const c=this.container,p=this._engine;this.id=t,this.group=s,this.effectClose=!0,this.effectFill=!0,this.shapeClose=!0,this.shapeFill=!0,this.pathRotation=!1,this.lastPathTime=0,this.destroyed=!1,this.unbreakable=!1,this.rotation=0,this.misplaced=!1,this.retina={maxDistance:{}},this.outType="normal",this.ignoresResizeRatio=!0;const d=c.retina.pixelRatio,f=c.actualOptions,u=(0,l.y)(this._engine,c,f.particles),g=u.effect.type,y=u.shape.type,{reduceDuplicates:v}=u;this.effect=(0,a.TA)(g,this.id,v),this.shape=(0,a.TA)(y,this.id,v);const b=u.effect,w=u.shape;if(e){if(e.effect?.type){const t=e.effect.type,i=(0,a.TA)(t,this.id,v);i&&(this.effect=i,b.load(e.effect))}if(e.shape?.type){const t=e.shape.type,i=(0,a.TA)(t,this.id,v);i&&(this.shape=i,w.load(e.shape))}}this.effectData=function(t,i,e,s){const o=i.options[t];if(o)return(0,a.zw)({close:i.close,fill:i.fill},(0,a.TA)(o,e,s))}(this.effect,b,this.id,v),this.shapeData=function(t,i,e,s){const o=i.options[t];if(o)return(0,a.zw)({close:i.close,fill:i.fill},(0,a.TA)(o,e,s))}(this.shape,w,this.id,v),u.load(e);const C=this.effectData;C&&u.load(C.particles);const m=this.shapeData;m&&u.load(m.particles);const z=new h.k(p,c);z.load(c.actualOptions.interactivity),z.load(u.interactivity),this.interactivity=z,this.effectFill=C?.fill??u.effect.fill,this.effectClose=C?.close??u.effect.close,this.shapeFill=m?.fill??u.shape.fill,this.shapeClose=m?.close??u.shape.close,this.options=u;const _=this.options.move.path;this.pathDelay=(0,o.VG)(_.delay.value)*n.Xu,_.generator&&(this.pathGenerator=this._engine.getPathGenerator(_.generator),this.pathGenerator&&c.addPath(_.generator,this.pathGenerator)&&await this.pathGenerator.init(c)),c.retina.initParticle(this),this.size=(0,a.Xs)(this.options.size,d),this.bubble={inRange:!1},this.slow={inRange:!1,factor:1},this._initPosition(i),this.initialVelocity=this._calculateVelocity(),this.velocity=this.initialVelocity.copy();this.moveDecay=1-(0,o.VG)(this.options.move.decay);const D=c.particles;D.setLastZIndex(this.position.z),this.zIndexFactor=this.position.z/c.zLayers,this.sides=24;let P=c.effectDrawers.get(this.effect);P||(P=this._engine.getEffectDrawer(this.effect),P&&c.effectDrawers.set(this.effect,P)),P?.loadEffect&&await P.loadEffect(this);let x=c.shapeDrawers.get(this.shape);x||(x=this._engine.getShapeDrawer(this.shape),x&&c.shapeDrawers.set(this.shape,x)),x?.loadShape&&await x.loadShape(this);const k=x?.getSidesCount;k&&(this.sides=k(this)),this.spawning=!1,this.shadowColor=(0,r.BN)(this.options.shadow.color);for(const o of D.updaters)await o.init(this);for(const o of D.movers)await(o.init?.(this));await(P?.particleInit?.(c,this)),await(x?.particleInit?.(c,this));for(const[,o]of c.plugins)o.particleCreated?.(this)}isInsideCanvas(){const t=this.getRadius(),i=this.container.canvas.size,e=this.position;return e.x>=-t&&e.y>=-t&&e.y<=i.height+t&&e.x<=i.width+t}isVisible(){return!this.destroyed&&!this.spawning&&this.isInsideCanvas()}reset(){for(const t of this.container.particles.updaters)t.reset?.(this)}}}}]);
//# sourceMappingURL=1769.56baf71c.chunk.js.map