{"version":3,"file":"static/js/2847.06f052e4.chunk.js","mappings":"iOAEaA,EAAb,WACI,WAAYC,GAAQ,2BAChBC,KAAKC,eAAL,iCAAsB,WAAOC,GAAP,wEACb,EAAKC,QAAQC,UADA,sBAER,IAAIC,MAAJ,UAAaC,EAAAA,GAAb,iCAFQ,uBAIZ,EAAKH,QAAQC,UAAU,CACzBG,IAAKL,EAAWK,IAChBC,KAAMN,EAAWM,KACjBC,aAAY,UAAEP,EAAWO,oBAAb,SACZC,IAAKR,EAAWQ,MARF,2CAAtB,kCAAAV,KAAA,eAWAA,KAAKG,QAAUJ,EAbvB,uCAeI,SAASY,GACAX,KAAKG,QAAQS,SACdZ,KAAKG,QAAQS,OAAS,IAE1BZ,KAAKG,QAAQS,OAAOC,KAAKF,KAnBjC,mDAqBI,WAAWG,GAAX,0FACYC,EAAuCD,EAAvCC,QAASC,EAA8BF,EAA9BE,OAAQC,EAAsBH,EAAtBG,SAAUC,EAAYJ,EAAZI,QAAkBP,EAAQM,EAASN,MAAOQ,EADjF,OAC2FR,QAD3F,IAC2FA,OAD3F,EAC2FA,EAAOQ,QACzFR,EAFT,oDAKII,EAAQK,YAAcF,GAClBP,EAAMJ,MAAOI,EAAMU,QAN3B,iCAOkC,+BAPlC,iBAOgBC,EAPhB,EAOgBA,SACAR,GARhB,wBAUaK,IACCI,EAAQZ,EAAMY,MAAOC,EAAM,CAC7BC,GAAIT,EACJU,GAAIV,GACLW,EApCA,EAoCWX,EACdD,EAAQa,UAAUT,EAASK,EAAIC,EAAGD,EAAIE,EAAGC,EAAUA,EAAWJ,IAftE,QAiBIR,EAAQK,YAvCiB,EAsB7B,4CArBJ,kFAwCI,WACI,OA1CoC,KAC5C,mDA2CI,WAAWS,GAAX,+EACUC,EAAUD,EAAUE,eACbC,SAAYhC,KAAKG,QAAQC,UAF1C,2DAK4B0B,EAAQE,SALpC,gEAKeC,EALf,kBAMcjC,KAAKG,QAAQC,UAAU6B,GANrC,uMA3CJ,+GAoDI,WAAgBhB,GAAhB,wEAC2B,UAAnBA,EAASiB,OAAwC,WAAnBjB,EAASiB,MAD/C,oDAISlC,KAAKG,QAAQS,SACdZ,KAAKG,QAAQS,OAAS,IAEpBqB,EAAYhB,EAASkB,UAP/B,oDAWkBnC,KAAKG,QAAQS,OAAOwB,MAAK,SAACC,GAAD,OAAOA,EAAE7B,OAASyB,EAAUzB,MAAQ6B,EAAEC,SAAWL,EAAUvB,OAXtG,kCAacV,KAAKC,eAAegC,GAblC,yBAccjC,KAAKuC,UAAUtB,GAd7B,iDApDJ,kHAqEI,WAAmBY,EAAWZ,GAA9B,2GAC2B,UAAnBA,EAASiB,OAAwC,WAAnBjB,EAASiB,MAD/C,oDAISlC,KAAKG,QAAQS,SACdZ,KAAKG,QAAQS,OAAS,IAEpBA,EAASZ,KAAKG,QAAQS,OAAQqB,EAAYhB,EAASkB,UAP7D,oDAWUK,EAAQvB,EAASwB,eAAgB9B,EAAQC,EAAOwB,MAAK,SAACC,GAAD,OAAOA,EAAE7B,OAASyB,EAAUzB,MAAQ6B,EAAEC,SAAWL,EAAUvB,OAX1H,oDAeUD,EAfV,UAeyBwB,EAAUxB,oBAfnC,QAemDE,EAAMF,cACjDE,EAAM+B,QAhBd,wBAiBQC,YAAW,WACF,EAAKC,aAAaf,EAAWZ,MAlB9C,+BAuBQN,EAAMkC,UAAWL,EAvBzB,kCAwB4C,uCAxB5C,wBAwBgBM,EAxBhB,EAwBgBA,kBAxBhB,UAyByBA,EAAkBnC,EAAOsB,EAAWO,EAAOvB,GAzBpE,QAyBQ8B,EAzBR,+BA4BQA,EAAW,CACPP,MAAAA,EACA1B,KAAMH,EACNQ,QAASR,EAAMQ,QACfZ,IAAKI,EAAMJ,IACXc,QAASV,EAAMU,QACf2B,aAAcrC,EAAMqC,aACpBC,QAAQ,EACR1B,MAAOU,EAAUiB,OAASjB,EAAUkB,OAC9BlB,EAAUiB,MAAQjB,EAAUkB,OAD3B,UAEDxC,EAAMY,aAFL,QA1GwC,EA6G/Cd,aAAcA,EACd6B,OAAQL,EAAUvB,KAxC9B,QA2CSqC,EAASxB,QACVwB,EAASxB,MAAQ,GAEf6B,EA9CV,UA8CiBnB,EAAUmB,YA9C3B,QA8CmCnC,EAASoC,UAAWC,EA9CvD,UA8C+DrB,EAAUqB,aA9CzE,QA8CkFrC,EAASsC,WAAYrD,EAAa,CAC5GS,MAAOoC,EACPK,KAAAA,EACAE,MAAAA,GAEJrC,EAASN,MAAQT,EAAWS,MAC5BM,EAASoC,UAAYnD,EAAWkD,KAChCnC,EAASsC,WAAarD,EAAWoD,MArDrC,iDArEJ","sources":["../node_modules/@tsparticles/shape-image/browser/ImageDrawer.js"],"sourcesContent":["import { errorPrefix } from \"@tsparticles/engine\";\nconst double = 2, defaultAlpha = 1, sides = 12, defaultRatio = 1;\nexport class ImageDrawer {\n    constructor(engine) {\n        this.loadImageShape = async (imageShape) => {\n            if (!this._engine.loadImage) {\n                throw new Error(`${errorPrefix} image shape not initialized`);\n            }\n            await this._engine.loadImage({\n                gif: imageShape.gif,\n                name: imageShape.name,\n                replaceColor: imageShape.replaceColor ?? false,\n                src: imageShape.src,\n            });\n        };\n        this._engine = engine;\n    }\n    addImage(image) {\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        this._engine.images.push(image);\n    }\n    async draw(data) {\n        const { context, radius, particle, opacity } = data, image = particle.image, element = image?.element;\n        if (!image) {\n            return;\n        }\n        context.globalAlpha = opacity;\n        if (image.gif && image.gifData) {\n            const { drawGif } = await import(\"./GifUtils/Utils.js\");\n            drawGif(data);\n        }\n        else if (element) {\n            const ratio = image.ratio, pos = {\n                x: -radius,\n                y: -radius,\n            }, diameter = radius * double;\n            context.drawImage(element, pos.x, pos.y, diameter, diameter / ratio);\n        }\n        context.globalAlpha = defaultAlpha;\n    }\n    getSidesCount() {\n        return sides;\n    }\n    async init(container) {\n        const options = container.actualOptions;\n        if (!options.preload || !this._engine.loadImage) {\n            return;\n        }\n        for (const imageData of options.preload) {\n            await this._engine.loadImage(imageData);\n        }\n    }\n    async loadShape(particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const imageData = particle.shapeData;\n        if (!imageData) {\n            return;\n        }\n        const image = this._engine.images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            await this.loadImageShape(imageData);\n            await this.loadShape(particle);\n        }\n    }\n    async particleInit(container, particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const images = this._engine.images, imageData = particle.shapeData;\n        if (!imageData) {\n            return;\n        }\n        const color = particle.getFillColor(), image = images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            return;\n        }\n        const replaceColor = imageData.replaceColor ?? image.replaceColor;\n        if (image.loading) {\n            setTimeout(() => {\n                void this.particleInit(container, particle);\n            });\n            return;\n        }\n        let imageRes;\n        if (image.svgData && color) {\n            const { replaceImageColor } = await import(\"./Utils.js\");\n            imageRes = await replaceImageColor(image, imageData, color, particle);\n        }\n        else {\n            imageRes = {\n                color,\n                data: image,\n                element: image.element,\n                gif: image.gif,\n                gifData: image.gifData,\n                gifLoopCount: image.gifLoopCount,\n                loaded: true,\n                ratio: imageData.width && imageData.height\n                    ? imageData.width / imageData.height\n                    : image.ratio ?? defaultRatio,\n                replaceColor: replaceColor,\n                source: imageData.src,\n            };\n        }\n        if (!imageRes.ratio) {\n            imageRes.ratio = 1;\n        }\n        const fill = imageData.fill ?? particle.shapeFill, close = imageData.close ?? particle.shapeClose, imageShape = {\n            image: imageRes,\n            fill,\n            close,\n        };\n        particle.image = imageShape.image;\n        particle.shapeFill = imageShape.fill;\n        particle.shapeClose = imageShape.close;\n    }\n}\n"],"names":["ImageDrawer","engine","this","loadImageShape","imageShape","_engine","loadImage","Error","errorPrefix","gif","name","replaceColor","src","image","images","push","data","context","radius","particle","opacity","element","globalAlpha","gifData","drawGif","ratio","pos","x","y","diameter","drawImage","container","options","actualOptions","preload","imageData","shape","shapeData","find","t","source","loadShape","color","getFillColor","loading","setTimeout","particleInit","svgData","replaceImageColor","imageRes","gifLoopCount","loaded","width","height","fill","shapeFill","close","shapeClose"],"sourceRoot":""}