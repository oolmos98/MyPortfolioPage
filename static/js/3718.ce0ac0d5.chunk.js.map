{"version":3,"file":"static/js/3718.ce0ac0d5.chunk.js","mappings":"oPAEMA,EAAc,+FACPC,EAAb,WACI,cAAc,eACVC,KAAKC,gBAAkB,IAAIC,IAFnC,sCAII,WAAU,gBACyBF,KAAKC,iBAD9B,IACN,2BAAqD,0BAAzCE,EAAyC,KAApCC,EAAoC,KAC7CA,aAAqBC,cACZ,OAATD,QAAS,IAATA,GAAAA,EAAWE,QACXN,KAAKC,gBAAgBM,OAAOJ,KAJ9B,iCAJd,mDAYI,WAAWK,GAAX,qFACgC,+BADhC,iBACYC,EADZ,EACYA,WACED,GAFd,2CAZJ,0GAgBI,WAAWE,GAAX,4EACUC,EAAUD,EAAUE,cACrBC,EAAAA,EAAAA,MAAgB,SAACC,GAAD,OAAOC,EAAAA,EAAAA,IAAUD,EAAGH,EAAQK,UAAUC,MAAMC,SAFrE,wDAKUC,EAAW,EAACC,EAAAA,EAAAA,IAAStB,KAAeuB,EAAeR,EAAAA,EAAAA,KAChD,SAACC,GAAD,OAAOH,EAAQK,UAAUC,MAAMN,QAAQG,MAC3CQ,MAAK,SAACR,GAAD,QAASA,QAEfS,EAAAA,EAAAA,IAA0BF,GAAc,SAACJ,GACjCA,EAAMO,MACNL,EAASM,MAAKL,EAAAA,EAAAA,IAASH,EAAMO,UAX7C,SAeUE,QAAQC,IAAIR,GAftB,2CAhBJ,oFAiCI,SAAgBS,UACLA,EAASxB,YAlCxB,2DAoCI,WAAmBM,EAAWkB,GAA9B,kGACUC,EAAS,EADnB,QACsBC,EAAYF,EAASE,iBAD3C,IAESA,GAAAA,EAAWC,MAFpB,oDAKUC,GAAQC,EAAAA,EAAAA,IAAyBH,EAAUC,MAAOH,EAASM,iBAAkBV,EALvF,UAK8FM,EAAUN,YALxG,QAKgH1B,EACvGkC,EANT,oDASU7B,EATV,UASmB6B,EATnB,YAS4BR,KAAQW,EAAenC,KAAKC,gBAAgBmC,IAAIjC,IAT5E,wBAWQyB,EAASxB,UAAY+B,EAX7B,8BAcUE,GAAaC,EAAAA,EAAAA,IAAYV,EAASW,KAAKR,OAASF,EAEhDW,GAAUF,EAAAA,EAAAA,IAAYV,EAASW,KAAKR,OACX,qBAApBU,gBAjBf,oBAkBcC,EAAS,IAAID,gBAAgBJ,EAAYA,GAAaM,EAAUD,EAAOE,WAAW,MAlBhG,mDAsBQD,EAAQnB,KAAR,cAAsBgB,EAAUX,EAAhC,cAA4CL,GAC5CmB,EAAQE,aAAe,SACvBF,EAAQG,UAAY,SACpBH,EAAQI,SAASf,EAAOQ,EAASA,GACjCpC,EAAYsC,EAAOM,wBA1B3B,4BA6BcN,EAASO,SAASC,cAAc,WAC/BC,MAAQd,EACfK,EAAOU,OAASf,EACVM,EAAUD,EAAOE,WAAW,MAhC1C,mDAoCQD,EAAQnB,KAAR,cAAsBgB,EAAUX,EAAhC,cAA4CL,GAC5CmB,EAAQE,aAAe,SACvBF,EAAQG,UAAY,SACpBH,EAAQI,SAASf,EAAOQ,EAASA,GACjCpC,EAAYsC,EAxCpB,eA0CI1C,KAAKC,gBAAgBoD,IAAIlD,EAAKC,GAC9BwB,EAASxB,UAAYA,EA3CzB,UA4CUsB,QAAQ4B,UA5ClB,iDApCJ","sources":["../node_modules/@tsparticles/shape-emoji/browser/EmojiDrawer.js"],"sourcesContent":["import { executeOnSingleOrMultiple, getRangeMax, isInArray, itemFromSingleOrMultiple, loadFont, } from \"@tsparticles/engine\";\nimport { validTypes } from \"./Constants.js\";\nconst defaultFont = '\"Twemoji Mozilla\", Apple Color Emoji, \"Segoe UI Emoji\", \"Noto Color Emoji\", \"EmojiOne Color\"';\nexport class EmojiDrawer {\n    constructor() {\n        this._emojiShapeDict = new Map();\n    }\n    destroy() {\n        for (const [key, emojiData] of this._emojiShapeDict) {\n            if (emojiData instanceof ImageBitmap) {\n                emojiData?.close();\n                this._emojiShapeDict.delete(key);\n            }\n        }\n    }\n    async draw(data) {\n        const { drawEmoji } = await import(\"./Utils.js\");\n        drawEmoji(data);\n    }\n    async init(container) {\n        const options = container.actualOptions;\n        if (!validTypes.find((t) => isInArray(t, options.particles.shape.type))) {\n            return;\n        }\n        const promises = [loadFont(defaultFont)], shapeOptions = validTypes\n            .map((t) => options.particles.shape.options[t])\n            .find((t) => !!t);\n        if (shapeOptions) {\n            executeOnSingleOrMultiple(shapeOptions, (shape) => {\n                if (shape.font) {\n                    promises.push(loadFont(shape.font));\n                }\n            });\n        }\n        await Promise.all(promises);\n    }\n    particleDestroy(particle) {\n        delete particle.emojiData;\n    }\n    async particleInit(container, particle) {\n        const double = 2, shapeData = particle.shapeData;\n        if (!shapeData?.value) {\n            return;\n        }\n        const emoji = itemFromSingleOrMultiple(shapeData.value, particle.randomIndexData), font = shapeData.font ?? defaultFont;\n        if (!emoji) {\n            return;\n        }\n        const key = `${emoji}_${font}`, existingData = this._emojiShapeDict.get(key);\n        if (existingData) {\n            particle.emojiData = existingData;\n            return;\n        }\n        const canvasSize = getRangeMax(particle.size.value) * double;\n        let emojiData;\n        const maxSize = getRangeMax(particle.size.value);\n        if (typeof OffscreenCanvas !== \"undefined\") {\n            const canvas = new OffscreenCanvas(canvasSize, canvasSize), context = canvas.getContext(\"2d\");\n            if (!context) {\n                return;\n            }\n            context.font = `400 ${maxSize * double}px ${font}`;\n            context.textBaseline = \"middle\";\n            context.textAlign = \"center\";\n            context.fillText(emoji, maxSize, maxSize);\n            emojiData = canvas.transferToImageBitmap();\n        }\n        else {\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = canvasSize;\n            canvas.height = canvasSize;\n            const context = canvas.getContext(\"2d\");\n            if (!context) {\n                return;\n            }\n            context.font = `400 ${maxSize * double}px ${font}`;\n            context.textBaseline = \"middle\";\n            context.textAlign = \"center\";\n            context.fillText(emoji, maxSize, maxSize);\n            emojiData = canvas;\n        }\n        this._emojiShapeDict.set(key, emojiData);\n        particle.emojiData = emojiData;\n        await Promise.resolve();\n    }\n}\n"],"names":["defaultFont","EmojiDrawer","this","_emojiShapeDict","Map","key","emojiData","ImageBitmap","close","delete","data","drawEmoji","container","options","actualOptions","validTypes","t","isInArray","particles","shape","type","promises","loadFont","shapeOptions","find","executeOnSingleOrMultiple","font","push","Promise","all","particle","double","shapeData","value","emoji","itemFromSingleOrMultiple","randomIndexData","existingData","get","canvasSize","getRangeMax","size","maxSize","OffscreenCanvas","canvas","context","getContext","textBaseline","textAlign","fillText","transferToImageBitmap","document","createElement","width","height","set","resolve"],"sourceRoot":""}