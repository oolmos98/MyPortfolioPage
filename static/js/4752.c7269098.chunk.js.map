{"version":3,"file":"static/js/4752.c7269098.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/shape-image/browser/ImageDrawer.js"],"sourcesContent":["import { errorPrefix } from \"@tsparticles/engine\";\nconst double = 2, defaultAlpha = 1, sides = 12, defaultRatio = 1;\nexport class ImageDrawer {\n    constructor(engine) {\n        this.loadImageShape = async (imageShape) => {\n            if (!this._engine.loadImage) {\n                throw new Error(`${errorPrefix} image shape not initialized`);\n            }\n            await this._engine.loadImage({\n                gif: imageShape.gif,\n                name: imageShape.name,\n                replaceColor: imageShape.replaceColor ?? false,\n                src: imageShape.src,\n            });\n        };\n        this._engine = engine;\n    }\n    addImage(image) {\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        this._engine.images.push(image);\n    }\n    async draw(data) {\n        const { context, radius, particle, opacity } = data, image = particle.image, element = image?.element;\n        if (!image) {\n            return;\n        }\n        context.globalAlpha = opacity;\n        if (image.gif && image.gifData) {\n            const { drawGif } = await import(\"./GifUtils/Utils.js\");\n            drawGif(data);\n        }\n        else if (element) {\n            const ratio = image.ratio, pos = {\n                x: -radius,\n                y: -radius,\n            }, diameter = radius * double;\n            context.drawImage(element, pos.x, pos.y, diameter, diameter / ratio);\n        }\n        context.globalAlpha = defaultAlpha;\n    }\n    getSidesCount() {\n        return sides;\n    }\n    async init(container) {\n        const options = container.actualOptions;\n        if (!options.preload || !this._engine.loadImage) {\n            return;\n        }\n        for (const imageData of options.preload) {\n            await this._engine.loadImage(imageData);\n        }\n    }\n    async loadShape(particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const imageData = particle.shapeData;\n        if (!imageData) {\n            return;\n        }\n        const image = this._engine.images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            await this.loadImageShape(imageData);\n            await this.loadShape(particle);\n        }\n    }\n    async particleInit(container, particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const images = this._engine.images, imageData = particle.shapeData;\n        if (!imageData) {\n            return;\n        }\n        const color = particle.getFillColor(), image = images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            return;\n        }\n        const replaceColor = imageData.replaceColor ?? image.replaceColor;\n        if (image.loading) {\n            setTimeout(() => {\n                void this.particleInit(container, particle);\n            });\n            return;\n        }\n        let imageRes;\n        if (image.svgData && color) {\n            const { replaceImageColor } = await import(\"./Utils.js\");\n            imageRes = await replaceImageColor(image, imageData, color, particle);\n        }\n        else {\n            imageRes = {\n                color,\n                data: image,\n                element: image.element,\n                gif: image.gif,\n                gifData: image.gifData,\n                gifLoopCount: image.gifLoopCount,\n                loaded: true,\n                ratio: imageData.width && imageData.height\n                    ? imageData.width / imageData.height\n                    : image.ratio ?? defaultRatio,\n                replaceColor: replaceColor,\n                source: imageData.src,\n            };\n        }\n        if (!imageRes.ratio) {\n            imageRes.ratio = 1;\n        }\n        const fill = imageData.fill ?? particle.shapeFill, close = imageData.close ?? particle.shapeClose, imageShape = {\n            image: imageRes,\n            fill,\n            close,\n        };\n        particle.image = imageShape.image;\n        particle.shapeFill = imageShape.fill;\n        particle.shapeClose = imageShape.close;\n    }\n}\n"],"names":["ImageDrawer","constructor","engine","this","loadImageShape","async","_engine","loadImage","Error","errorPrefix","gif","imageShape","name","replaceColor","src","addImage","image","images","push","draw","data","context","radius","particle","opacity","element","globalAlpha","gifData","drawGif","ratio","pos","x","y","diameter","drawImage","getSidesCount","init","container","options","actualOptions","preload","imageData","loadShape","shape","shapeData","find","t","source","particleInit","color","getFillColor","loading","setTimeout","imageRes","svgData","replaceImageColor","gifLoopCount","loaded","width","height","fill","shapeFill","close","shapeClose"],"sourceRoot":""}